<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Postman / Newman JSON Report Viewer — Charts</title>
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --muted: #94a3b8;
    --text: #e5e7eb;
    --accent: #22c55e;
    --fail: #ef4444;
    --warn: #f59e0b;
    --card: #0b1220;
    --chip: #1f2937;
    --border: #1f2937;
  }
  html, body { height: 100%; }
  body {
    margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial;
    background: linear-gradient(180deg, var(--bg) 0%, #0b1020 100%);
    color: var(--text);
  }
  header {
    position: sticky; top: 0; z-index: 10;
    background: rgba(15, 23, 42, .9);
    backdrop-filter: blur(6px);
    border-bottom: 1px solid var(--border);
    padding: 12px 16px;
    display: flex; gap: 16px; align-items: center; justify-content: space-between;
  }
  .brand { font-weight: 700; letter-spacing: .3px; }
  .brand small { color: var(--muted); font-weight: 500; }
  .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap;}
  input[type="file"] { color: var(--muted); }
  .btn {
    border: 1px solid #374151; background: #0b1220; color: var(--text);
    padding: 8px 12px; border-radius: 10px; cursor: pointer;
  }
  .btn:hover { background:#10182b }
  main { padding: 16px; max-width: 1200px; margin: 0 auto; }
  .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin-top: 12px; }
  .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 14px; }
  .card h3 { margin: 4px 0 8px; font-size: 14px; color: var(--muted); font-weight: 600; letter-spacing: .2px; }
  .value { font-size: 28px; font-weight: 800; }
  .value.ok { color: var(--accent); }
  .value.fail { color: var(--fail); }
  .value.warn { color: var(--warn); }
  .meta { color: var(--muted); font-size: 12px; margin-top: 4px; }
  .grid { width: 100%; border-collapse: collapse; margin-top: 16px; background: #0b1220; border-radius: 14px; overflow: hidden; border: 1px solid var(--border); }
  .grid th, .grid td { padding: 10px 12px; border-bottom: 1px solid var(--border); text-align: left; vertical-align: top; }
  .grid th { background: #0f1a33; color: #cbd5e1; font-size: 12px; text-transform: uppercase; letter-spacing: .5px; }
  .status-chip { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #234; }
  .status-pass { background: rgba(34,197,94,.15); color: #86efac; border-color: rgba(34,197,94,.4); }
  .status-fail { background: rgba(239,68,68,.15); color: #fca5a5; border-color: rgba(239,68,68,.4); }
  .status-skip { background: rgba(245,158,11,.15); color: #fcd34d; border-color: rgba(245,158,11,.4); }
  .flex { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  .muted { color: var(--muted); }
  .mono { font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; font-size: 12px; }
  .accordion { margin-top: 8px; }
  details { background: #0a0f1e; border: 1px solid var(--border); border-radius: 10px; padding: 8px 12px; margin-top: 8px; }
  details[open] { background: #0c1629; }
  summary { cursor: pointer; color: #cbd5e1; font-weight: 600; }
  pre { background: #040816; border: 1px solid var(--border); color: #e5e7eb; padding: 10px; border-radius: 10px; overflow: auto; max-height: 360px; }
  .footer { color: var(--muted); font-size: 12px; margin: 24px 0; text-align: center; }
  .search-bar { margin-top: 12px; display: flex; gap: 8px; }
  .search-bar input { flex: 1; padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: #0b1220; color: var(--text); }
  .tag { background: var(--chip); color: #cbd5e1; padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #334155; }
  .right { text-align: right; }
  .charts { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; margin-top: 16px; }
  .chart-card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 12px; }
  .chart-card h4 { margin: 4px 0 8px; font-size: 14px; color: var(--muted); }
  canvas { width: 100%; height: 240px; }
  @media (max-width: 720px) { .hide-sm { display: none; } }
</style>
</head>
<body>
  <header>
    <div class="brand">Postman / Newman Report Viewer <small>offline • charts</small></div>
    <div class="controls">
      <input type="file" id="file" accept=".json">
      <button class="btn" id="demo">Load demo</button>
      <button class="btn" id="download">Export filtered table (CSV)</button>
    </div>
  </header>
  <main>
    <div id="welcome">
      <p>Drop a <b>Newman JSON report</b> or Postman <b>Collection Runner export</b> here. This viewer renders a dashboard with totals, pass/fail, charts, and drill-down into each request. Works fully offline.</p>
      <ul>
        <li>Summary cards and charts (pass/fail, response times, status codes)</li>
        <li>Searchable table with per-request details, assertions, and raw bodies</li>
        <li>One static HTML file — no external libraries</li>
      </ul>
    </div>

    <section id="summary" style="display:none;">
      <div class="cards" id="cards"></div>

      <div class="charts">
        <div class="chart-card">
          <h4>Assertions (pass vs fail)</h4>
          <canvas id="chartAssertions"></canvas>
        </div>
        <div class="chart-card">
          <h4>Requests (pass vs fail)</h4>
          <canvas id="chartRequests"></canvas>
        </div>
        <div class="chart-card">
          <h4>Status code distribution</h4>
          <canvas id="chartStatus"></canvas>
        </div>
        <div class="chart-card">
          <h4>Response times (ms) — timeline</h4>
          <canvas id="chartTimeline"></canvas>
        </div>
        <div class="chart-card">
          <h4>Top 10 slowest requests</h4>
          <canvas id="chartSlowest"></canvas>
        </div>
      </div>

      <div class="search-bar">
        <input id="search" type="search" placeholder="Filter by name, status, method, URL, assertion…">
        <span id="filterCounts" class="muted"></span>
      </div>
      <table class="grid" id="table">
        <thead>
          <tr>
            <th>Item</th>
            <th class="hide-sm">Method</th>
            <th class="hide-sm">URL</th>
            <th>Assertions</th>
            <th class="hide-sm">Status</th>
            <th class="right">Time (ms)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="footer" id="meta"></div>
    </section>
  </main>

<script>
  const byId = id => document.getElementById(id);
  const fileInput = byId('file');
  const demoBtn = byId('demo');
  const downloadBtn = byId('download');
  const summary = byId('summary');
  const cards = byId('cards');
  const table = byId('table').querySelector('tbody');
  const meta = byId('meta');
  const search = byId('search');
  const welcome = byId('welcome');
  const filterCounts = byId('filterCounts');

  const chartEls = {
    assertions: byId('chartAssertions'),
    requests: byId('chartRequests'),
    status: byId('chartStatus'),
    timeline: byId('chartTimeline'),
    slowest: byId('chartSlowest')
  };
  let charts = {};

  const DEMO = {
    "collection": {"info":{"name":"Demo Petstore"}},
    "run": {
      "stats": {
        "iterations":{"total":1,"failed":0},
        "items":{"total":3,"failed":0},
        "requests":{"total":3,"failed":1},
        "testScripts":{"total":3,"failed":0},
        "assertions":{"total":6,"failed":2}
      },
      "timings":{"responseAverage": 128},
      "executions":[
        {"item":{"name":"List pets"},"request":{"method":"GET","url":{"raw":"https://api.example.com/v1/pets"}},
         "response":{"code":200,"responseTime":110},
         "assertions":[{"assertion":"status code is 200","error":null},{"assertion":"has items","error":null}]
        },
        {"item":{"name":"Create pet"},"request":{"method":"POST","url":{"raw":"https://api.example.com/v1/pets"}},
         "response":{"code":400,"responseTime":210},
         "assertions":[{"assertion":"status code is 201","error":{"name":"AssertionError","message":"expected 400 to equal 201"}},
                       {"assertion":"json has id","error":{"name":"TypeError","message":"Cannot read properties of undefined"}}]
        },
        {"item":{"name":"Get pet"},"request":{"method":"GET","url":{"raw":"https://api.example.com/v1/pets/1"}},
         "response":{"code":200,"responseTime":65},
         "assertions":[{"assertion":"status code is 200","error":null},
                       {"assertion":"has name","error":null}]
        }
      ]
    }
  };

  fileInput.addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        render(data);
      } catch (err) {
        alert("Could not parse JSON: " + err.message);
      }
    };
    reader.readAsText(f);
  });

  demoBtn.addEventListener('click', () => render(DEMO));

  function safe(v, d="") { return v==null ? d : v; }

  function flattenExecutions(run) {
    const execs = safe(run.executions, []);
    return execs.map(ex => {
      const name = safe(ex.item && ex.item.name, "Unnamed");
      const method = safe(ex.request && ex.request.method, "");
      const url = safe(ex.request && ex.request.url && (ex.request.url.raw || (ex.request.url.protocol?`${ex.request.url.protocol}://${(ex.request.url.host||[]).join('.')}${ex.request.url.path?'/'+ex.request.url.path.join('/'):''}`:"")), "");
      const code = safe(ex.response && ex.response.code, null);
      const time = safe(ex.response && ex.response.responseTime, null);
      const assertions = (ex.assertions||[]).map(a => ({ name: safe(a.assertion,"(unnamed)"), passed: !a.error, error: a.error }));
      const passed = assertions.every(a => a.passed);
      return { name, method, url, code, time, assertions, passed, raw: ex };
    });
  }

  function calcPercentile(arr, p){ 
    if(!arr.length) return null;
    const a = [...arr].sort((x,y)=>x-y);
    const idx = Math.ceil(p/100*(a.length-1));
    return a[idx];
  }

  function render(data) {
    welcome.style.display = 'none';
    summary.style.display = '';

    const run = data.run || {};
    const stats = run.stats || {};
    const timings = run.timings || {};
    const executions = flattenExecutions(run);

    // Totals
    const totals = {
      items: safe(stats.items && stats.items.total, executions.length),
      requests: safe(stats.requests && stats.requests.total, executions.length),
      assertions: safe(stats.assertions && stats.assertions.total, executions.reduce((a,b)=>a + b.assertions.length,0)),
      failedRequests: safe(stats.requests && stats.requests.failed, executions.filter(e=>!e.passed).length),
      failedAssertions: safe(stats.assertions && stats.assertions.failed, executions.reduce((a,b)=>a + b.assertions.filter(x=>!x.passed).length,0)),
      avg: safe(timings.responseAverage, Math.round(executions.reduce((a,b)=>a+(+b.time||0),0)/Math.max(1,executions.length)))
    };

    // Cards
    cards.innerHTML = `
      <div class="card"><h3>Collection</h3><div class="value">${escapeHtml(safe(data.collection && data.collection.info && data.collection.info.name,"(unknown)"))}</div><div class="meta">${new Date().toLocaleString()}</div></div>
      <div class="card"><h3>Requests</h3><div class="value ${totals.failedRequests? 'warn':''}">${totals.requests}</div><div class="meta"><span class="tag">${totals.requests - totals.failedRequests} passed</span> <span class="tag">${totals.failedRequests} failed</span></div></div>
      <div class="card"><h3>Assertions</h3><div class="value ${totals.failedAssertions? 'fail':'ok'}">${totals.assertions}</div><div class="meta"><span class="tag">${totals.assertions - totals.failedAssertions} passed</span> <span class="tag">${totals.failedAssertions} failed</span></div></div>
      <div class="card"><h3>Avg Response</h3><div class="value">${isFinite(totals.avg)?totals.avg:'–'}</div><div class="meta">p50/p95 shown in timeline</div></div>
    `;

    // Build datasets for charts
    const times = executions.map(e=>e.time||0).filter(x=>x!=null);
    const p50 = calcPercentile(times, 50);
    const p95 = calcPercentile(times, 95);

    const failedAsserts = executions.reduce((a,e)=>a + e.assertions.filter(x=>!x.passed).length,0);
    const passAsserts = executions.reduce((a,e)=>a + e.assertions.filter(x=>x.passed).length,0);

    const reqPassed = executions.filter(e=>e.assertions.every(a=>a.passed)).length;
    const reqFailed = executions.length - reqPassed;

    const codeMap = {};
    executions.forEach(e => {
      const c = e.code==null ? '—' : String(e.code);
      codeMap[c] = (codeMap[c]||0)+1;
    });
    const statusLabels = Object.keys(codeMap).sort((a,b)=> (a==='—')?1: (b==='—')?-1: (+a - +b));
    const statusValues = statusLabels.map(k=>codeMap[k]);

    const sortedByTime = [...executions].filter(e=>e.time!=null).sort((a,b)=>b.time-a.time).slice(0,10);
    const slowLabels = sortedByTime.map(e=>e.name);
    const slowValues = sortedByTime.map(e=>e.time);

    // Draw charts
    destroyCharts();
    charts.assertions = pieChart(chartEls.assertions, ['Pass','Fail'], [passAsserts, failedAsserts]);
    charts.requests = pieChart(chartEls.requests, ['Pass','Fail'], [reqPassed, reqFailed]);
    charts.status = barChart(chartEls.status, statusLabels, statusValues, {xLabel:'Status code', yLabel:'Count'});
    charts.timeline = lineChart(chartEls.timeline, executions.map((e,i)=>i+1), times, {xLabel:'Request #', yLabel:'ms', markers:[{label:'p50', value:p50},{label:'p95', value:p95}]});
    charts.slowest = barChart(chartEls.slowest, slowLabels, slowValues, {xLabel:'Request', yLabel:'ms'});

    // Table
    let rows = executions.map((e, idx) => {
      const totalAsserts = e.assertions.length;
      const failedAssertsRow = e.assertions.filter(a=>!a.passed).length;
      const statusClass = failedAssertsRow ? 'status-fail' : 'status-pass';
      const statusText = failedAssertsRow ? `Failed (${failedAssertsRow})` : 'Passed';
      return `
        <tr data-index="${idx}">
          <td>
            <div class="flex">
              <span class="status-chip ${statusClass}">${statusText}</span>
              <strong>${escapeHtml(e.name)}</strong>
            </div>
            ${renderAssertionsInline(e.assertions)}
            ${renderAccordion(e)}
          </td>
          <td class="hide-sm mono">${escapeHtml(e.method||'')}</td>
          <td class="hide-sm mono">${escapeHtml(e.url||'')}</td>
          <td>${failedAssertsRow}/${totalAsserts} failed</td>
          <td class="hide-sm">${e.code ?? ''}</td>
          <td class="right mono">${e.time ?? ''}</td>
        </tr>
      `;
    }).join('');
    table.innerHTML = rows;

    meta.textContent = `Rendered locally • Items: ${totals.items} • Requests: ${totals.requests} • Assertions: ${totals.assertions} • Failures: ${totals.failedAssertions} • Avg: ${totals.avg} ms • p50: ${p50??'–'} • p95: ${p95??'–'}`;

    // Simple search filter
    search.oninput = () => {
      const q = search.value.trim().toLowerCase();
      let visible = 0;
      [...table.querySelectorAll('tr')].forEach(tr => {
        const text = tr.innerText.toLowerCase();
        const show = !q || text.includes(q);
        tr.style.display = show ? '' : 'none';
        if (show) visible++;
      });
      filterCounts.textContent = q ? `${visible} rows match` : '';
    };

    // CSV export of visible rows
    downloadBtn.onclick = () => {
      const rows = [...table.querySelectorAll('tr')].filter(tr=>tr.style.display!=='none').map(tr => {
        const tds = tr.querySelectorAll('td');
        const item = tds[0].innerText.replace(/\s+/g,' ').trim();
        const method = tds[1]?.innerText || '';
        const url = tds[2]?.innerText || '';
        const assertions = tds[3]?.innerText || '';
        const status = tds[4]?.innerText || '';
        const time = tds[5]?.innerText || '';
        return [item, method, url, assertions, status, time];
      });
      const csv = 'Item,Method,URL,Assertions,Status,Time(ms)\n' + rows.map(r=>r.map(s=>`"${s.replace(/"/g,'""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'postman-report.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };
  }

  function renderAssertionsInline(assertions) {
    if (!assertions || !assertions.length) return `<div class="muted">No assertions</div>`;
    const chips = assertions.slice(0,4).map(a => `<span class="tag">${escapeHtml(a.name)}${a.passed?'':' ❌'}</span>`).join(' ');
    const more = assertions.length > 4 ? `<span class="muted">+${assertions.length-4} more</span>` : '';
    return `<div class="flex" style="margin-top:6px;">${chips} ${more}</div>`;
  }

  function renderAccordion(e) {
    const req = e.raw.request || {};
    const res = e.raw.response || {};
    const reqBody = (req.body && (req.body.raw || JSON.stringify(req.body, null, 2))) || '';
    const resBody = res.stream ? tryDecode(res.stream) : (res.body || '');
    const assertionList = e.assertions.map(a => `<li>${a.passed ? '✅' : '❌'} <span class="mono">${escapeHtml(a.name)}</span>${a.passed?'':`: <span class="muted">${escapeHtml(a.error && (a.error.message || a.error.name) || 'Error')}</span>`}</li>`).join('');

    return `
      <div class="accordion">
        <details>
          <summary>Details</summary>
          <div class="muted" style="margin:6px 0;">${escapeHtml(req.method||'')} ${escapeHtml((req.url && (req.url.raw || '')) || '')}</div>
          <div class="flex" style="gap:12px; flex-wrap:wrap;">
            <div><span class="muted">Status:</span> <span class="mono">${res.code ?? ''}</span></div>
            <div><span class="muted">Time:</span> <span class="mono">${res.responseTime ?? ''} ms</span></div>
          </div>
          <h4>Assertions</h4>
          <ul>${assertionList || '<li class="muted">None</li>'}</ul>
          <h4>Request</h4>
          ${renderHeaders(req.header, 'Request headers')}
          ${reqBody ? `<pre class="mono">${escapeHtml(reqBody)}</pre>` : '<div class="muted">No body</div>'}
          <h4>Response</h4>
          ${renderHeaders(res.header, 'Response headers')}
          ${resBody ? `<pre class="mono">${escapeHtml(resBody)}</pre>` : '<div class="muted">No body</div>'}
        </details>
      </div>
    `;
  }

  function renderHeaders(hdrs, title) {
    const list = (hdrs || []).map(h => `<li><span class="mono">${escapeHtml(h.key||'')}:</span> <span class="muted">${escapeHtml(h.value||'')}</span></li>`).join('');
    return list ? `<details><summary>${title}</summary><ul>${list}</ul></details>` : '';
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function tryDecode(stream) {
    try {
      if (Array.isArray(stream)) {
        const bytes = new Uint8Array(stream);
        const dec = new TextDecoder('utf-8', {fatal:false});
        return dec.decode(bytes);
      }
      if (typeof stream === 'object' && stream.type === 'Buffer' && Array.isArray(stream.data)) {
        const bytes = new Uint8Array(stream.data);
        const dec = new TextDecoder('utf-8', {fatal:false});
        return dec.decode(bytes);
      }
      return typeof stream === 'string' ? stream : JSON.stringify(stream, null, 2);
    } catch(e) {
      return '[binary response]';
    }
  }

  // ---- Minimal charting (Canvas2D) — no external libs ----
  const palette = ['#60a5fa','#34d399','#fbbf24','#f87171','#a78bfa','#f472b6','#22d3ee','#f59e0b'];

  function getCtx(canvas){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    return {ctx, w: rect.width, h: rect.height};
  }

  function clearCanvas(canvas){
    const {ctx,w,h} = getCtx(canvas);
    ctx.clearRect(0,0,w,h);
  }

  function drawAxes(ctx, w, h, padding, xLabel, yLabel){
    const left = padding.left, right = w - padding.right, top = padding.top, bottom = h - padding.bottom;
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(left, top); ctx.lineTo(left, bottom); ctx.lineTo(right, bottom); ctx.stroke();
    ctx.fillStyle = '#94a3b8'; ctx.font = '12px sans-serif';
    if (xLabel) ctx.fillText(xLabel, (left+right)/2 - ctx.measureText(xLabel).width/2, h - 6);
    if (yLabel) { ctx.save(); ctx.translate(10, (top+bottom)/2); ctx.rotate(-Math.PI/2); ctx.fillText(yLabel, 0, 0); ctx.restore(); }
    return {left,right,top,bottom};
  }

  function barChart(canvas, labels, values, {xLabel='', yLabel=''}={}){
    const {ctx,w,h} = getCtx(canvas);
    const padding = {left:50,right:12,top:16,bottom:36};
    const area = drawAxes(ctx,w,h,padding,xLabel,yLabel);
    const max = Math.max(1, ...values);
    const barW = (area.right - area.left) / values.length * 0.8;
    const gap = (area.right - area.left) / values.length * 0.2;
    ctx.fillStyle = '#64748b'; ctx.font = '10px sans-serif';
    values.forEach((v,i)=>{
      const x = area.left + i*(barW+gap) + gap/2;
      const y = area.bottom - (v/max)*(area.bottom - area.top);
      ctx.fillStyle = palette[i%palette.length];
      ctx.fillRect(x,y,barW,area.bottom - y);
      // labels (x)
      const lbl = String(labels[i]).length>12 ? String(labels[i]).slice(0,10)+'…' : String(labels[i]);
      ctx.fillStyle = '#94a3b8';
      ctx.fillText(lbl, x, area.bottom + 12);
    });
    return {type:'bar', canvas};
  }

  function pieChart(canvas, labels, values){
    const {ctx,w,h} = getCtx(canvas);
    const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 20;
    const total = Math.max(1, values.reduce((a,b)=>a+b,0));
    let start = -Math.PI/2;
    values.forEach((v,i)=>{
      const angle = (v/total) * Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,r,start,start+angle);
      ctx.closePath();
      ctx.fillStyle = palette[i%palette.length];
      ctx.fill();
      start += angle;
    });
    // legend
    ctx.font = '12px sans-serif'; ctx.fillStyle = '#cbd5e1';
    labels.forEach((l,i)=>{
      const y = 18 + i*16;
      ctx.fillStyle = palette[i%palette.length];
      ctx.fillRect(w-140, y-10, 10,10);
      ctx.fillStyle = '#cbd5e1';
      ctx.fillText(`${l} — ${values[i]}`, w-124, y);
    });
    return {type:'pie', canvas};
  }

  function lineChart(canvas, labels, values, {xLabel='', yLabel='', markers=[]}={}){
    const {ctx,w,h} = getCtx(canvas);
    const padding = {left:50,right:12,top:16,bottom:36};
    const area = drawAxes(ctx,w,h,padding,xLabel,yLabel);
    const xs = labels.map((_,i)=> area.left + i*(area.right-area.left)/Math.max(1, (labels.length-1)));
    const min = Math.min(...values, 0), max = Math.max(...values, 1);
    const ys = values.map(v => area.bottom - ( (v - min) / (max - min || 1) )*(area.bottom-area.top));
    // grid
    ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 1;
    for(let i=0;i<5;i++){ const y = area.top + i*(area.bottom-area.top)/4; ctx.beginPath(); ctx.moveTo(area.left,y); ctx.lineTo(area.right,y); ctx.stroke(); }
    // line
    ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 2;
    ctx.beginPath();
    xs.forEach((x,i)=>{ if(i===0) ctx.moveTo(x,ys[i]); else ctx.lineTo(x,ys[i]); });
    ctx.stroke();
    // markers (p50/p95)
    markers.forEach((m, idx)=>{
      const y = area.bottom - ((m.value - min)/(max - min || 1))*(area.bottom-area.top);
      ctx.strokeStyle = ['#34d399','#f59e0b','#f87171'][idx%3];
      ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(area.left,y); ctx.lineTo(area.right,y); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#cbd5e1'; ctx.font='12px sans-serif';
      ctx.fillText(`${m.label}: ${m.value}`, area.right-120, y-6);
    });
    return {type:'line', canvas};
  }

  function destroyCharts(){
    charts = {};
    Object.values(chartEls).forEach(clearCanvas);
  }
</script>
</body>
</html>
